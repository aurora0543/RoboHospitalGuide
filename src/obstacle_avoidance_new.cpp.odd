#include "nav.h"  // åŒ…å«å¯¼èˆªç›¸å…³å£°æ˜ï¼ˆåŠ¨ä½œå‡½æ•°ã€æ§åˆ¶æ ‡å¿—ï¼‰
#include <iostream>      // æ§åˆ¶å° I/O
#include <thread>        // å¤šçº¿ç¨‹ä¸ sleep
#include <chrono>        // æ—¶é—´åº¦é‡
#include <cmath>         // æ•°å­¦å‡½æ•°
#include <gpiod.hpp>
#include <sys/time.h>
#include "ultrasonic.h"

using namespace std::chrono;  // ç®€åŒ–æ—¶é’Ÿè°ƒç”¨

static constexpr float SAFE_DISTANCE = 20.0f;     // å®‰å…¨è·ç¦»é˜ˆå€¼
static constexpr float EXTRA_CLEARANCE = 10.0f;   // é¢å¤–æ¸…é™¤è·ç¦»

// å…¨å±€ä½ç½®å’Œèˆªå‘ï¼Œç”¨äºè·¨é˜¶æ®µç´¯è®¡
struct Position { float x=0, y=0; };
static Position currentPosition;   // å½“å‰åæ ‡ï¼ˆcmï¼‰

// æ›´æ–°ä½ç½®å‡½æ•°ï¼ˆå•ä½ cmï¼‰
void updatePosition(float dist, float heading) {
    float rad = heading * M_PI / 180.0f;
    currentPosition.x += dist * std::cos(rad);
    currentPosition.y += dist * std::sin(rad);
    std::cout << "[å®šä½] ç§»åŠ¨ " << dist << " cm, å½“å‰ä½ç½® (" \
              << currentPosition.x << ", " << currentPosition.y \
              << "), èˆªå‘ " << heading << "Â°\n";
}

// åŒ¿åå‘½åç©ºé—´ï¼Œç”¨äºå†…éƒ¨å‡½æ•°å®ç°
namespace {
    // è·å–å½“å‰æ—¶é—´ï¼ˆå¾®ç§’ï¼‰
    long getMicrotime() {
        struct timeval tv;
        gettimeofday(&tv, nullptr);
        return tv.tv_sec * 1000000 + tv.tv_usec;
    }

    // æµ‹é‡æŒ‡å®š trig/echo å¼•è„šçš„è·ç¦»ï¼ˆcmï¼‰
    float measureDistance(int trigPin, int echoPin) {
        gpiod::chip chip("gpiochip0");
        auto trigLine = chip.get_line(trigPin);
        auto echoLine = chip.get_line(echoPin);
        trigLine.request({"ultrasonic", gpiod::line_request::DIRECTION_OUTPUT, 0}, 0);
        echoLine.request({"ultrasonic", gpiod::line_request::DIRECTION_INPUT, 0});

        // è§¦å‘è¶…å£°æ³¢è„‰å†²
        trigLine.set_value(0);
        std::this_thread::sleep_for(std::chrono::microseconds(2));
        trigLine.set_value(1);
        std::this_thread::sleep_for(std::chrono::microseconds(10));
        trigLine.set_value(0);

        // ç­‰å¾…å›å£°å¼€å§‹
        while (echoLine.get_value() == 0);
        long startTime = getMicrotime();
        // ç­‰å¾…å›å£°ç»“æŸ
        while (echoLine.get_value() == 1);
        long travelTime = getMicrotime() - startTime;

        // å£°é€Ÿçº¦ 343 m/s -> 0.0343 cm/Âµsï¼Œé™¤ä»¥ 2 å¾—åˆ°è·ç¦»
        return travelTime * 0.0343f / 2.0f;
    }

    // æ£€æµ‹å‰æ–¹éšœç¢
    bool isObstacleAhead() {
        float d = measureDistance(TRIG_FRONT, ECHO_FRONT);
        std::cout << "[æ£€æµ‹] å‰æ–¹è·ç¦» = " << d << " cm\n";
        return d < SAFE_DISTANCE;
    }
}

namespace Nav {

    extern void avoidObstacle(Motor*, Servo*, YawTracker*, float& heading, float& remaining, float& lateralComp);

    void navigationThread(Motor* motor, Servo* servo, YawTracker* yaw, nlohmann::json navJson) {
        Motor& m = *motor;
        Servo& s = *servo;
        YawTracker& y = *yaw;

        float heading = 0.0f;      // å½“å‰èˆªå‘
        float lateralComp = 0.0f;  // è·¨é˜¶æ®µä¾§å‘è¡¥å¿ï¼ˆç´¯è®¡ï¼‰

        while (true) {
            if (startNavigation.load()) {
                std::cout << "\nğŸš¦ å¼€å§‹å¯¼èˆª...\n";

                for (const auto& step : navJson["path"]) {
                    std::string action = step["action"];
                    float value = step["value"];

                    if (action == "moveForward") {
                        float remaining = value;  // æœ¬é˜¶æ®µå‰©ä½™è·ç¦»
                        std::cout << "â¬†ï¸ ç›®æ ‡å‰è¿› " << remaining << " cm\n";
                        m.forward(30);
                        while (remaining > 0.0f) {
                            if (isObstacleAhead()) {
                                avoidObstacle(motor, servo, yaw, heading, remaining, lateralComp);
                                m.stop();
                                break;
                            }
                            std::this_thread::sleep_for(std::chrono::milliseconds(10));
                            remaining -= 1.0f;
                            updatePosition(1.0f, heading);
                        }
                        m.stop();
                        if (remaining > 0.0f) {
                            std::cout << "â¬†ï¸ å›åˆ°åŸèˆªå‘åç»§ç»­å‰è¿› " << remaining << " cm\n";
                            m.forward(30);
                            std::this_thread::sleep_for(std::chrono::milliseconds((int)(remaining * 10)));
                            updatePosition(remaining, heading);
                            m.stop();
                        }

                    } else if (action == "turnLeft") {
                        std::cout << "â†ªï¸ å·¦è½¬ " << value << " åº¦...\n";
                        Nav::turnLeft(m, s, y, value);
                        heading = std::fmod(heading + value + 360.0f, 360.0f);
                        // âœ… åˆå¹¶ lateralComp åˆ°æœ¬é˜¶æ®µ value ä¸­
                        if (lateralComp != 0.0f) {
                            float lateralHeading = (lateralComp > 0) ? std::fmod(heading - 90 + 360.0f, 360.0f)
                                                                          : std::fmod(heading + 90, 360.0f);
                            float headingDiff = std::fabs(std::fmod(lateralHeading - heading + 360.0f, 360.0f));
                            bool sameDirection = (headingDiff < 90.0f || headingDiff > 270.0f);

                            float adjusted = sameDirection ? (value - std::abs(lateralComp))
                                                          : (value + std::abs(lateralComp));

                            std::cout << "â¡ï¸ å·²åˆå¹¶ä¾§å‘è¡¥å¿ï¼Œè°ƒæ•´å‰è¿›è·ç¦»ä¸º " << adjusted << " cm\n";
                            value = adjusted;
                            lateralComp = 0.0f;
                        }
                    } else if (action == "turnRight") {
                        std::cout << "â†©ï¸ å³è½¬ " << value << " åº¦...\n";
                        Nav::turnRight(m, s, y, value);
                        heading = std::fmod(heading - value + 360.0f, 360.0f);
                        // â›”ï¸ å·²åˆå¹¶åˆ° moveForward ä¸­ï¼Œæ­¤å¤„ä¸å†æ‰§è¡Œ

                    } else {
                        std::cerr << "âŒ æœªçŸ¥å¯¼èˆªåŠ¨ä½œ: " << action << "\n";
                    }
                }

                std::cout << "ğŸ å¯¼èˆªå®Œæˆï¼\n";
                startNavigation.store(false);
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    }

    void avoidObstacle(Motor* motor, Servo* servo, YawTracker* yaw,
                       float& heading, float& remaining, float& lateralComp) {
        Motor& m = *motor;
        Servo& s = *servo;
        YawTracker& y = *yaw;

        float pending = remaining;
        std::cout << "[é¿éšœ] è®°å½•å‰©ä½™è·ç¦»: " << pending << " cm\n";

        float ld = measureDistance(TRIG_LEFT, ECHO_LEFT);
        float rd = measureDistance(TRIG_RIGHT, ECHO_RIGHT);
        bool goLeft = (ld > rd);
        std::cout << "[é¿éšœ] é€‰æ‹©" << (goLeft?"å·¦ä¾§":"å³ä¾§") << "é¿éšœ\n";

        if (goLeft) { Nav::turnLeft(m, s, y, 90); heading = std::fmod(heading + 90 + 360.0f, 360.0f); }
        else       { Nav::turnRight(m,s, y, 90); heading = std::fmod(heading - 90 + 360.0f, 360.0f); }

        float lateral = 0.0f;
        while (true) {
            float sense = goLeft ? measureDistance(TRIG_RIGHT, ECHO_RIGHT)
                                  : measureDistance(TRIG_LEFT,  ECHO_LEFT);
            if (sense >= SAFE_DISTANCE) break;
            m.forward(30);
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            lateral += 1.0f;
            updatePosition(1.0f, heading);
        }

        std::cout << "[é¿éšœ] ä¾§è¾¹å®‰å…¨ï¼Œé¢å¤–å‰è¿› " << EXTRA_CLEARANCE << " cm\n";
        m.forward(30);
        std::this_thread::sleep_for(std::chrono::milliseconds((int)(EXTRA_CLEARANCE * 10)));
        lateral += EXTRA_CLEARANCE;
        updatePosition(EXTRA_CLEARANCE, heading);
        m.stop();

        lateralComp += (goLeft? lateral : -lateral);
        std::cout << "[é¿éšœ] ç´¯è®¡ä¾§å‘è¡¥å¿: " << lateralComp << " cm\n";

        if (goLeft) { Nav::turnRight(m,s,y,90); heading = std::fmod(heading - 90 + 360.0f, 360.0f); }
        else        { Nav::turnLeft(m, s, y, 90); heading = std::fmod(heading + 90 + 360.0f, 360.0f); }

        remaining = pending;
        std::cout << "[é¿éšœ] æ¢å¤å‰©ä½™å‰è¿›: " << remaining << " cm\n";
    }

}  // namespace Nav
